/**
 * @template T
 * @typedef {keyof T extends infer K ? K extends keyof T ? K : never : never} _StringKeys
 */

/**
 * @template T, K
 * @typedef {`${K & string}` | ([T] extends [readonly (infer _)[]] ? number extends T["length"] ? number extends K ? `${bigint}` : `${K & number}` : never : number extends K ? `${bigint}` : `${K & number}`)} __StringKeys
 */

/**
 * @template T
 * @typedef {__StringKeys<T, _StringKeys<T>>} StringKeys
 */

/**
 * @template T
 * @typedef {keyof T extends infer K ? Extract<K, keyof T> : never} NonHomomorphicKeyof
 */

/**
 * @template T
 * @template {StringKeys<T>} K
 * @typedef {{
 *	[K2 in NonHomomorphicKeyof<T>]: K extends __StringKeys<T, K2> ? T[K2] : never
 * }[NonHomomorphicKeyof<T>]} GetStringKey
 */

/**
 * @template O
 * @template {string} P
 * @template [V = unknown]
 * @typedef {(P & `${string}.` extends never ? P : P & `${string}.`) extends infer Q ? Q extends `${infer A}.${infer B}` ? A extends StringKeys<O> ? `${A}.${AutoPath<GetStringKey<O, A>, B, V>}` : never : Q extends StringKeys<O> ? (GetStringKey<O, Q> extends V ? Exclude<P, `${string}.`> : never) | (StringKeys<GetStringKey<O, Q>> extends never ? never : `${Q}.`) : StringKeys<O> | (Q extends "" ? `${bigint}` extends StringKeys<O> ? "[index]" : never : never) : never} AutoPath
 */

/**
 * @template O
 * @template {string} P
 * @typedef {P extends `${infer A}.${infer B}` ? A extends StringKeys<O> ? GetPath<GetStringKey<O, A>, B> : never : P extends StringKeys<O> ? GetStringKey<O, P> : never} GetPath
 */

const FILENAME = "/exploit/do.js";
const HOSTNAME = "joesguns";
const BASERAMCOST = 1.6;

/**
 * @template T
 * @template [Q = GetPath<NS, T>]
 * @param {NS} ns
 * @param {AutoPath<I, T>} func
 * @param {Q extends (...args: infer R) => infer _ ? R : never} args
 * @returns {Promise<Q extends (...args: infer _) => infer R ? R : never>}
 */
// eslint-disable-next-line no-unused-vars
async function outsource(ns, func, ...args) {
	const data = await outsourceNoException(ns, func, ...args);
	if (data === null) throw new Error("Outsourcing failed! Got null");
	return data;
}

/**
 * @template T
 * @template [Q = GetPath<NS, T>]
 * @param {NS} ns
 * @param {AutoPath<I, T>} func
 * @param {Q extends (...args: infer R) => infer _ ? R : never} args
 * @returns {Promise<(Q extends (...args: infer _) => infer R ? R : never) | null>}
 */
async function outsourceNoException(ns, func, ...args) {
	const convertedArgs = args.map(a => JSON.stringify(a));

	ns.scp(FILENAME, HOSTNAME, "home");
	const pid = ns.exec(FILENAME, HOSTNAME, { ramOverride: BASERAMCOST + ns.getFunctionRamCost(func) }, func, ...convertedArgs);
	if (pid < 1) return null;

	while (ns.isRunning(pid)) await ns.asleep(10);

	const data = ns.readPort(pid);
	const result = parse(data);

	if (!isResult(result)) return null;
	if (result.didError) {
		console.error("Outsourcing errored!", func, args, result);
		return null;
	}
	return result.data;
}

/**
 * @typedef {{
 * 	desc: "FAILURE";
 * 	didError: true;
 * 	error: unknown;
 * }} Failure
 */

/**
 * @template T
 * @template [P = GetPath<NS, T>]
 * @typedef {{
 * 	desc: "SUCCESS";
 * 	didError: false;
 * 	data: P extends (...args: infer _) => infer R ? R : never;
 * }} Success
 */

/**
 * @template T
 * @typedef {Success<T> | Failure} Result
 */

/** @param {NS} ns */
// eslint-disable-next-line no-unused-vars
async function main(ns) {
	const [func, ...args] = ns.args;
	const funcArgs = func.split(".");

	try {
		const argObjs = args.map(a => parse(a));
		let nsFunc = ns[funcArgs.shift()];

		while (typeof nsFunc !== "function") {
			if (funcArgs.length === 0) throw new Error(`Input keyword is not a callable property of NS: "ns.${func}" is not a function.`);
			nsFunc = nsFunc?.[funcArgs.shift()];
		}

		const result = await nsFunc(...argObjs);

		const object = {
			desc: "SUCCESS",
			didError: false,
			data: result,
		};

		ns.writePort(ns.pid, JSON.stringify(object));
	} catch (e) {
		console.error(ns.pid, func, e ?? new Error("UNKNOWN ERROR"));

		const result = {
			desc: "FAILURE",
			didError: true,
			error: e ?? 500
		};

		ns.writePort(ns.pid, JSON.stringify(result));
	}
}

/**
 * @param {unknown} obj
 * @returns {obj is Result<T>}
 */
function isResult(obj) {
	return obj !== null && typeof obj === "object" && "desc" in obj && (obj?.desc === "FAILURE" || obj?.desc === "SUCCESS");
}

/**
 * @param {string} a 
 * @returns {unknown}
 */
function parse(a) {
	try { return JSON.parse(a); } catch { return a; }
}