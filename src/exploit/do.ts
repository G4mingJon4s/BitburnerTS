/* eslint-disable @typescript-eslint/no-unsafe-return */
import type { NS } from "@ns";

type DeepKeys<T> = {
  [K in keyof T]: T[K] extends object
		? K extends string
			? K | `${K}.${DeepKeys<T[K]> & string}`
			: never
		: K;
}[keyof T];

type ReturnTypeFromInterface<T, K extends DeepKeys<T>> = K extends `${infer P}.${infer Q}`
  ? P extends keyof T
    ? ReturnTypeFromInterface<T[P], Q & DeepKeys<T[P]>>
    : never
  : K extends keyof T
		?	T[K] extends (...args: infer _U) => infer R
    ? R
    : never
	: never;

type ArgumentsFromInterface<T, K extends DeepKeys<T>> = K extends `${infer P}.${infer Q}`
  ? P extends keyof T
    ? ArgumentsFromInterface<T[P], Q & DeepKeys<T[P]>>
    : never
  : K extends keyof T
	? T[K] extends (...args: infer R) => infer _U
    ? R
    : never
  : never;

export const FILENAME = "/exploit/do.js";
export const HOSTNAME = "joesguns";

export async function outsource<T extends DeepKeys<NS>>(ns: NS, func: T, ...args: ArgumentsFromInterface<NS, T>): Promise<ReturnTypeFromInterface<NS, T>> {
	const data = await outsourceNoException(ns, func, ...args);
	if (data === null) throw new Error("Outsourcing failed! Got null");
	return data;
}

export async function outsourceNoException<T extends DeepKeys<NS>>(ns: NS, func: T, ...args: ArgumentsFromInterface<NS, T>): Promise<ReturnTypeFromInterface<NS, T> | null> {
	ns.scp(FILENAME, HOSTNAME, "home");
	const pid = ns.exec(FILENAME, HOSTNAME, 1, func, ...args);
	if (pid < 1) return null;

	while (ns.isRunning(pid)) await ns.asleep(10);

	const data = ns.readPort(pid) as string;
	const result = parse(data);

	if (!isResult<T>(result)) return null;
	if (result.didError) {
		console.error("Outsourcing errored!", func, args, result);
		return null;
	}
	return result.data;
}

type Failure = {
	desc: "FAILURE";
	didError: true;
	error: unknown;
}

type Success<T extends DeepKeys<NS>> = {
	desc: "SUCCESS";
	didError: false;
	data: ReturnTypeFromInterface<NS, T>;
}

type Result<T extends DeepKeys<NS>> = Success<T> | Failure;

export async function main(ns: NS) {
	const [func, ...args] = ns.args as [DeepKeys<NS> & string, ...string[]];
	const funcArgs = func.split(".");
	
	/*
		THERE ARE NO KNOWN TYPES AFTER THIS POINT.
		EXPLAINATION:
		We know that the argument "func" is any key of NS (hopefully). We also know that any "args" passed after that are strings, as any objects etc. were stringified.
		We know "funcArgs" is an array of strings as we split up a string into multiple strings. We cannot identify the type of "argObjs", as we don't know what function was passed in.
		It could be that the function doesn't take any arguments, but it could also be that the function has multiple parameters to fill in. We can't account for all possibilities, so
		everything after getting the basic info from strings is unknown.
	*/

	try {
		const argObjs = args.map(a => parse(a));
		let nsFunc = ns[funcArgs.shift() as keyof NS] as unknown;

		while (typeof nsFunc !== "function") {
			if (funcArgs.length === 0) throw new Error(`Input keyword is not a callable property of NS: "ns.${func}" is not a function.`);
			nsFunc = nsFunc?.[funcArgs.shift() as keyof typeof nsFunc];
		}

		const result: unknown = await nsFunc(...argObjs); // typing as unknown to avoid any

		const object = {
			desc: "SUCCESS",
			didError: false,
			data: result,
		};

		ns.writePort(ns.pid, JSON.stringify(object));
	} catch (e) {
		console.error(ns.pid, func, e);

		const result = {
			desc: "FAILURE",
			didError: true,
			error: e
		};

		ns.writePort(ns.pid, JSON.stringify(result));
	}
}

export function isResult<T extends DeepKeys<NS>>(obj: unknown): obj is Result<T> {
	return obj !== null && typeof obj === "object" && "desc" in obj && (obj.desc === "FAILURE" || obj.desc === "SUCCESS");
}

export function parse(a: string): unknown {
	try { return JSON.parse(a); } catch { return a; }
}