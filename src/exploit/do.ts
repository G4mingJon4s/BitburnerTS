/* eslint-disable @typescript-eslint/no-unsafe-return */
import type { NS } from "@ns";

export type DeepKeys<T> = {
  [K in keyof T]: T[K] extends object
		? K extends string
			? K | `${K}.${DeepKeys<T[K]> & string}`
			: never
		: K;
}[keyof T];

export type ReturnTypeFromInterface<T, K extends DeepKeys<T>> = K extends `${infer P}.${infer Q}`
  ? P extends keyof T
    ? ReturnTypeFromInterface<T[P], Q & DeepKeys<T[P]>>
    : never
  : K extends keyof T
		?	T[K] extends (...args: infer _U) => infer R
    ? R
    : never
	: never;

export type ArgumentsFromInterface<T, K extends DeepKeys<T>> = K extends `${infer P}.${infer Q}`
  ? P extends keyof T
    ? ArgumentsFromInterface<T[P], Q & DeepKeys<T[P]>>
    : never
  : K extends keyof T
	? T[K] extends (...args: infer R) => infer _U
    ? R
    : never
  : never;

export const FILENAME = "/exploit/do.js";
export const HOSTNAME = "joesguns";
export const BASERAMCOST = 1.6;

export async function outsource<T extends DeepKeys<NS>>(ns: NS, func: T, ...args: ArgumentsFromInterface<NS, T>): Promise<ReturnTypeFromInterface<NS, T>> {
	const data = await outsourceNoException(ns, func, ...args);
	if (data === null) throw new Error("Outsourcing failed! Got null");
	return data;
}

export async function outsourceNoException<T extends DeepKeys<NS>>(ns: NS, func: T, ...args: ArgumentsFromInterface<NS, T>): Promise<ReturnTypeFromInterface<NS, T> | null> {
	ns.scp(FILENAME, HOSTNAME, "home");
	const pid = ns.exec(FILENAME, HOSTNAME, { ramOverride: BASERAMCOST + ns.getFunctionRamCost(func) }, func, ...args);
	if (pid < 1) return null;

	while (ns.isRunning(pid)) await ns.asleep(10);

	const data = ns.readPort(pid) as string;
	const result = parse(data);

	if (!isResult<T>(result)) return null;
	if (result.didError) {
		console.error("Outsourcing errored!", func, args, result);
		return null;
	}
	return result.data;
}

type Failure = {
	desc: "FAILURE";
	didError: true;
	error: unknown;
}

type Success<T extends DeepKeys<NS>> = {
	desc: "SUCCESS";
	didError: false;
	data: ReturnTypeFromInterface<NS, T>;
}

type Result<T extends DeepKeys<NS>> = Success<T> | Failure;

export async function main(ns: NS) {
	const [func, ...args] = ns.args as [string, ...string[]];
	const funcArgs = func.split(".");

	try {
		const argObjs = args.map(a => parse(a));
		let nsFunc = ns[funcArgs.shift() as keyof NS] as ((...args: unknown[]) => unknown) | undefined;

		while (typeof nsFunc !== "function") {
			if (funcArgs.length === 0) throw new Error(`Input keyword is not a callable property of NS: "ns.${func}" is not a function.`);
			nsFunc = nsFunc?.[funcArgs.shift() as keyof typeof nsFunc];
		}

		const result = await nsFunc(...argObjs);

		const object = {
			desc: "SUCCESS",
			didError: false,
			data: result,
		};

		ns.writePort(ns.pid, JSON.stringify(object));
	} catch (e) {
		console.error(ns.pid, func, e ?? new Error("UNKNOWN ERROR"));

		const result = {
			desc: "FAILURE",
			didError: true,
			error: e ?? 500
		};

		ns.writePort(ns.pid, JSON.stringify(result));
	}
}

export function isResult<T extends DeepKeys<NS>>(obj: unknown): obj is Result<T> {
	return obj !== null && typeof obj === "object" && "desc" in obj && (obj.desc === "FAILURE" || obj.desc === "SUCCESS");
}

export function parse(a: string): unknown {
	try { return JSON.parse(a); } catch { return a; }
}