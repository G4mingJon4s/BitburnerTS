/* eslint-disable @typescript-eslint/no-unsafe-return */
import type { NS } from "@ns";

type DeepKeys<T> = {
  [K in keyof T]: T[K] extends object ? K extends string ? K | `${K}.${DeepKeys<T[K]> & string}` : never : K;
}[keyof T];

type ReturnTypeFromInterface<T, K extends DeepKeys<T>> = K extends `${infer P}.${infer Q}`
  ? P extends keyof T
    ? ReturnTypeFromInterface<T[P], Q & DeepKeys<T[P]>>
    : never
  : K extends keyof T
		?	T[K] extends (...args: infer _U) => infer R
    ? R
    : never
	: never;

type ArgumentsFromInterface<T, K extends DeepKeys<T>> = K extends `${infer P}.${infer Q}`
  ? P extends keyof T
    ? ArgumentsFromInterface<T[P], Q & DeepKeys<T[P]>>
    : never
  : K extends keyof T
	? T[K] extends (...args: infer R) => infer _U
    ? R
    : never
  : never;

export const FILENAME = "/exploit/do.js";
export const HOSTNAME = "joesguns";

export async function outsource<T extends DeepKeys<NS>>(ns: NS, func: T, ...args: ArgumentsFromInterface<NS, T>): Promise<ReturnTypeFromInterface<NS, T>> {
	const data = await outsourceNoException(ns, func, ...args);
	if (data === null) throw new Error("Outsourcing failed! Got null");
	return data;
}

export async function outsourceNoException<T extends DeepKeys<NS>>(ns: NS, func: T, ...args: ArgumentsFromInterface<NS, T>): Promise<ReturnTypeFromInterface<NS, T> | null> {
	ns.scp(FILENAME, HOSTNAME, "home");
	const pid = ns.exec(FILENAME, HOSTNAME, 1, func, ...args);
	if (pid < 1) return null;

	while (ns.isRunning(pid)) await ns.asleep(10);

	const data = ns.readPort(pid) as string;
	const result = JSON.parse(data) as unknown;

	if (!isResult<T>(result)) return null;
	if (result.didError) {
		console.error("Outsourcing errored!", func, args, result);
		return null;
	}
	return result.data;
}

type Failure = {
	desc: "FAILURE";
	didError: true;
	error: unknown;
}

type Success<T extends DeepKeys<NS>> = {
	desc: "SUCCESS";
	didError: false;
	data: ReturnTypeFromInterface<NS, T>;
}

type Result<T extends DeepKeys<NS>> = Success<T> | Failure;

export async function main(ns: NS) {
	try {
		const [func, ...args] = ns.args as string[];
		const argObjs = args.map(a => parse(a));

		const nsFunc = ns[func as keyof NS] as (...args: unknown[]) => unknown;

		const result = await nsFunc(...argObjs);

		const object = {
			desc: "SUCCESS",
			didError: false,
			data: result,
		};

		ns.writePort(ns.pid, JSON.stringify(object));
	} catch (e) {
		const result = {
			desc: "FAILURE",
			didError: true,
			error: e
		};

		ns.writePort(ns.pid, JSON.stringify(result));
	}
}

export function isResult<T extends DeepKeys<NS>>(obj: unknown): obj is Result<T> {
	return obj !== null && typeof obj === "object" && "desc" in obj && (obj.desc === "FAILURE" || obj.desc === "SUCCESS");
}

export function parse(a: string): unknown {
	try { return JSON.parse(a); } catch { return a; }
}